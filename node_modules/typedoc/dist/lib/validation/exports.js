"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateExports = void 0;
const path_1 = require("path");
const ts = require("typescript");
const models_1 = require("../models");
function validateExports(project, logger, intentionallyNotExported) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let current = project;
    const queue = [];
    const intentional = new Set(intentionallyNotExported);
    const seenIntentional = new Set();
    const warned = new Set();
    const visitor = (0, models_1.makeRecursiveVisitor)({
        reference(type) {
            var _a, _b;
            // If we don't have a symbol, then this was an intentionally broken reference.
            const symbol = type.getSymbol();
            if (!type.reflection && symbol) {
                if (intentional.has(symbol.name)) {
                    seenIntentional.add(symbol.name);
                }
                if ((symbol.flags & ts.SymbolFlags.TypeParameter) === 0 &&
                    !intentional.has(symbol.name) &&
                    !warned.has(symbol) &&
                    !((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some((d) => d.getSourceFile().fileName.includes("node_modules")))) {
                    warned.add(symbol);
                    const decl = (_b = symbol.declarations) === null || _b === void 0 ? void 0 : _b[0];
                    if (decl) {
                        const { line } = ts.getLineAndCharacterOfPosition(decl.getSourceFile(), decl.getStart());
                        const file = (0, path_1.relative)(process.cwd(), decl.getSourceFile().fileName);
                        logger.warn(`${type.name}, defined at ${file}:${line}, is referenced by ${current.getFullName()} but not included in the documentation.`);
                    }
                }
            }
        },
        reflection(type) {
            queue.push(type.declaration);
        },
    });
    const add = (item) => {
        if (!item)
            return;
        if (item instanceof models_1.Reflection) {
            queue.push(item);
        }
        else {
            queue.push(...item);
        }
    };
    do {
        if (current instanceof models_1.ContainerReflection) {
            add(current.children);
        }
        if (current instanceof models_1.DeclarationReflection) {
            (_a = current.type) === null || _a === void 0 ? void 0 : _a.visit(visitor);
            add(current.typeParameters);
            add(current.signatures);
            add(current.indexSignature);
            add(current.getSignature);
            add(current.setSignature);
            (_b = current.overwrites) === null || _b === void 0 ? void 0 : _b.visit(visitor);
            // Do not check inheritedFrom, it doesn't always make sense to export a base type.
            // Do not validate implementationOf will always be defined or intentionally broken.
            // Do not check extendedTypes, it doesn't always make sense to export a base type.
            // Do not validate extendedBy, guaranteed to all be in the documentation.
            (_c = current.implementedTypes) === null || _c === void 0 ? void 0 : _c.forEach((type) => type.visit(visitor));
            // Do not validate implementedBy, guaranteed to all be in the documentation.
        }
        if (current instanceof models_1.SignatureReflection) {
            add(current.parameters);
            add(current.typeParameters);
            (_d = current.type) === null || _d === void 0 ? void 0 : _d.visit(visitor);
            (_e = current.overwrites) === null || _e === void 0 ? void 0 : _e.visit(visitor);
            // Do not check inheritedFrom, it doesn't always make sense to export a base type.
            // Do not validate implementationOf will always be defined or intentionally broken.
        }
        if (current instanceof models_1.ParameterReflection) {
            (_f = current.type) === null || _f === void 0 ? void 0 : _f.visit(visitor);
        }
        if (current instanceof models_1.TypeParameterReflection) {
            (_g = current.type) === null || _g === void 0 ? void 0 : _g.visit(visitor);
            (_h = current.default) === null || _h === void 0 ? void 0 : _h.visit(visitor);
        }
    } while ((current = queue.shift()));
    for (const x of seenIntentional) {
        intentional.delete(x);
    }
    if (intentional.size) {
        logger.warn("The following symbols were marked as intentionally not exported, but were either not referenced in the documentation, or were exported:\n\t" +
            Array.from(intentional).join("\n\t"));
    }
}
exports.validateExports = validateExports;
